{"pageProps":{"frontmatter":{"title":"Kubeflow Goals","description":"Goals and vision for Kubeflow's future as a steering committee member","date":"November 20, 2024"},"post":{"content":"\n# Kubeflow Goals\n\n**Author:**[Francisco Javier Arceo](https://www.linkedin.com/in/franciscojavierarceo/) | **Date:**Nov 20, 2024\n\nWe are at a critical moment in time for AI/ML. Open-source models have taken center stage, and resilient, scalable infrastructure has become critical to the success of AI. However, infrastructure alone isn't enoughâ€”tools must inspire excitement and engagement among users.\n\nAs a Kubeflow Steering Committee member, my core focus would be to drive engagement and increase adoption by improving the experience and impact of Kubeflow for end users, ensuring it's not only a robust platform but also one that people love to use. More precisely, I would focus on 6 key goals.\n\n1. **Expanding Kubeflow Adoption:** increasing awareness, adoption, and engagement through collaborations with enterprises and startups.  \n2. **Making RAG a first class priority:** the AI community has settled on Retrieval Augmented Generation (RAG) as a critical component for production AI. I will work to make this a new focus area for Kubeflow.  \n3. **Improving the User/Developer Experience for Model Developers/Users:** simplifying workflows and enhancing usability to reduce barriers to entry.  \n4. **Engaging and Empowering AI Engineers:** supporting software engineers integrating AI/ML into their products. By providing intuitive workflows, thoughtful defaults, and subsets of Kubeflow's tooling, we can ensure AI Engineers are set up for long-term success as they scale their products.  \n5. **Building a more Feature-Complete AI/ML Platform:** driving development of critical features to support end-to-end AI/ML workflows.  \n6. **Improving Documentation:** ensuring comprehensive, user-friendly docs and resources for the community.  \n7. **Strengthening the Community:** fostering a vibrant, inclusive contributor and user ecosystem to support Kubeflow's long-term growth.\n\nI believe [I am qualified](https://www.linkedin.com/in/franciscojavierarceo/) to help lead Kubeflow's [values and structure](https://github.com/kubeflow/community/blob/master/KUBEFLOW-STEERING-COMMITTEE.md#kubeflow-steering-committee) because of my past open-source contributions and professional experience. \n\nAs a [leader](https://docs.google.com/document/d/1DgtDmLCBnXQF9qva9X6Vac2ehpplj2iz6ZYw76NL8gM/edit?tab=t.0), [maintainer](https://feast.dev/blog/the-future-of-feast/), and [contributor](https://insights.lfx.linuxfoundation.org/foundation/lf-ai-foundation/overview/github?project=feast&repository=https:%2F%2Fgithub.com%2Ffeast-dev%2Ffeast&routedFrom=Github&dateFilters=Last%2010%20Years&dateRange=2014-11-20%20to%202024-11-20&compare=PP&granularity=year&hideBots=true) to Feast, I have helped evolve a critical component of the MLOps ecosystem, driving innovation in feature storage and retrieval. My 12+ [years of experience](https://www.linkedin.com/in/franciscojavierarceo) at the intersection of data engineering, AI/ML engineering, and MLOps include technical and managerial leadership roles at Red Hat, Affirm, Fast, Goldman Sachs, and others. Across these positions, I've designed, built, and scaled AI **models and platforms** in production, gaining a deep understanding of user pain points and opportunities to innovate.\n\nI bring this experience to Kubeflow with a vision of making it the leading open source platform for scalable, production-grade AI/ML. By expanding adoption, improving the user experience, and delivering a feature-complete solution, my goal is to empower MLOps teams to build a powerful AI/ML platform that enables their success and expands the global impact of AI.\n","excerpt":""},"previousPost":{"slug":"difficulties-deploying-ml-in-production","frontmatter":{"title":"The Difficulties of Machine Learning in Production","description":"10 lessons from a decade of deploying machine learning","date":"August 5, 2022"},"excerpt":"","content":"\n\n<blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">you know, deploying machine learning models is very, very difficult</p>&mdash; Francisco Javier Arceo (@franciscojarceo) <a href=\"https://twitter.com/franciscojarceo/status/1544110672660807680?ref_src=twsrc%5Etfw\">July 5, 2022</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n\n# Some History\n\nI've been working in the application of machine learning for nearly 10 years\nand it's quite exciting to have experienced firsthand how much machine learning\ninfrastructure has changed in that time.\n\nI spent the first half of my career as a \"modeler\" where I focused on building\nmachine learning and statistical models for a bunch of different use cases. Over\ntime I found that I migrated more and more to the engineering work to get the model\ndeployed because I always found this to be a bottleneck in the work I did.\n\nConcretely, I'd build a pretty good model that suggested it would be impactful\n(based on expectations of the performance) but I often found it was a rather\nextraordinary effort to get it live and interacting with users/customers.\n\nThis is quite well cited by the data science / MLOps community today but it was\nless obvious back in 2012 and it was very frustrating. The good news is that, for\nbetter or worse, I was rather relentless in getting my models over the finish line.\n\nWhich, in many ways, is what led me to the career I have stumbled into today as\nan engineering manager working at the intersection of machine learning, data,\nand engineering.\n\nAll this to say that I have spent a surprising share of the last decade working\non getting models into live product experiences. Since I have some lessons\nlearned and some potentially useful opinions, I thought I'd write them down.\n\n# Ten Lessons from a decade of Deploying ML\n\n## 0: Create strict contracts with the input source of your features\n\nThis is the single most important and most frequently omitted step in the\nmachine learning pipeline. I say this because making unit tests for schemas is\nmostly tedious work but, in my experience, this is 90% of the errors\nthat come up in production. Whether it be a missing field, new field, or a\nchange to the type of the field, it just seems to happen to *everyone* at some\npoint.\n\nWhether your model is batch/offline or real-time/online having data/schema validations\nis critical as often ML models are dependent upon data from a wide variety of\ndifferent upstream sources where the data producer has no knowledge about the\nusage of the data, so a trivial change on their end could make cause a world of\nchaos for you and the consumers of your models.\n\nSome limitations with this approach are (1) that you may not always know the\ntop-level producer of your data so making a test may not be so trivial if you\nrely on an intermediate data consumer to provide you the data or if you rely on\na vendor that changes something without your notice (this happens more often\nthan you think). Regardless of the limitations having some tests here\nwill certainly provide you more coverage and ensure higher quality.\n\n## 1: Test your feature engineering more than you want to\n\nFeature engineering is code.\n\nWhen software engineers write code for microservices we write lots of unit\ntests to capture schema changes, validate edge cases, and make the code\nmore readable.\n\nUnfortunately, these software design concepts don't always translate to\nmachine learning applications. This isn't always the case but often this happens\nbecause the skills needed to build good machine learning models are rarely\nthe same as the skills needed to write good software.\n\nSo the recommendation is simple: write lots of unit tests covering all of\nthe edge cases that come up during feature engineering.\n\nWhat are some of the edge cases?\n\n- Return type changed\n- division by zero\n- incorrect logic\n- incorrect imputation\n- incomplete if-else\n- and others\n\nIn many ways this is laborious but it makes sense because the bulk of the work\n(and code) in machine learning for tabular data is in the feature engineering\nand the pipelines supporting those features, so that is where the bulk of the\ntesting should be.\n\n## 2: Codify the range and scale of your features\n\nScale and range checking in practice can be rather challenging as sometimes\nit's very hard to know what the upper or lower bound will be but often you can\napply sensible heuristics. For example, you can test that features that are\ncalculated as ratios or rates to between [0,1] and test large but sensible\nextremum values for other features.\n\n## 3: Separate your model execution from your feature engineering\n\nPost-estimation a model is a rather trivial function call applied to a matrix\nor tensor for most algorithms. The pipeline is usually as simple as:\n\n```\n# lots of stuff above\nfeatures = build_features()\npredictions = model.fit(features=features)\n# lots of stuff  below\n```\n\nBut there are challenges that come up with the `model.fit()`. Specifically,\nsome models can be very large in size, especially ones using neural networks.\nIf you do have a large model you have to make sure you think about: right-sizing\nthe server that will hold the model in memory, where that model will be stored,\nhow the server will load the model, and what fail-over looks like.\n\nThese hardware and software considerations can get complicated on their own,\nwhich is why it's worth not mixing up the model execution with the feature\nengineering pipelines or other stuff if you don't have to.\n\n## 4: Separate matrix serialization from model execution\n\nThis is another small step in practice but is very consequential as errors come\nup and identifying the root cause can often be hairy. So I recommend that you\nseparate the matrix serialization from your model execution and feature\nengineering because it is cleaner and you'll be able to triage inevitable\nbreaks sooner.\n\nTwo specific issues that come up are (1) passing a character to a matrix and (2)\npassing a missing value (e.g., `np.nan`). (1) is not a number and in order for\nthe algorithms to do their fancy stuff they need explicit numbers and (2)\nis effectively equivalent but some matrix implementations in python will allow\nyou to hold a placeholder for a missing value and may even behave with some\nbasic operations but will ultimately fail at the `model.fit()` step.\n\nHere are two trivial examples that show this problem in action:\n```python\n# Just showing that this works as normal\nxs = np.matrix([[1,2],[3,4]])\nprint(xs * 1.3)\n#matrix([[1.3, 2.6],\n#        [3.9, 5.2]])\n\n# Example 1: Now let's try that character\nxs = np.matrix([[1,2],[3,'c']])\nprint(xs * 1.3)\n# ...it breaks! and eventually you see this confusing error:\n# numpy.core._exceptions.UFuncTypeError: ufunc 'multiply' did not contain a loop with signature matching types (dtype('<U21'), dtype('<U3')) -> None\n\n# Example 2: Now how about that np.nan?\nxs = np.matrix([[np.nan, np.nan],[np.nan, np.nan]])\nprint(xs * 1.3)\n# Wild that this works\nmatrix([[nan, nan],\n        [nan, nan]])\n```\n\nTrivial in code, chaotic when it blows up a server.\n\n## 5: Avoid mixing business logic with statistical operations\n\nMachine learning systems, even those as simple as what is effectively a\nglorified calculator can be surprisingly complicated so I generally recommend\nkeeping any business logic away from the machine learning or feature engineering\nwork. It's simply because both business logic and ml code tend to grow\ncomplicated for all sorts of valid reasons but the skills used to debug or\neven read and understand either are quite different, so the separation tends to\nhelp with that.\n\n## 6: Precompute what you can\n\nI could write an entire book about feature engineering and the complexity that\nit holds but the TL;DR version is that features tend to have all sorts of\ndifferent time representations (some feature representing real-time, others\ndata from yesterday, and others from 3 seconds ago) and this temporal component\nends up creating a lot of engineering complexity.\n\nA general recommendation: precompute and run in batch as much as you possibly\ncan. You can actually get quite far for many use cases this way without having\nto build the complexity that comes with real-time and streaming use cases.\n\nOnce you do get to real-time and streaming use cases, there's a whole other\nbunch of work to do and I won't cover that here.\n\n## 7: Load your model at service build time\n\nIn an ideal world your model is an isolated service or an isolated endpoint with\nit's own memory (maybe on kubernetes, maybe not) and you simply load it at build\ntime. It's pretty simple but this all means you could store your model artifact\nin either some [model registry](https://www.mlflow.org/docs/latest/model-registry.html)\nor in an S3 buckets.\n\nIf you're early in your model building it's absolutely fine to store the model\nin GitHub if it's not terribly huge but generally it's preferred to put it in\nsome other storage meant for larger file sizes.\n\n## 8: Right size your server\n\nGoing back again to the challenges that come up when having a large model, you\nmay not just be encountering issues there. You may also find that some of the\ndata that you have to process in real-time can get bulky (e.g., if you're\ndynamically calculating features based on user history and look back through a\nyear's worth of data for a bunch of different things).\n\nSo it's important to not only right size your server for the model that you will\nbe using but also for the features that you will be calculating in real-time.\nThis is usually fairly manageable and if you precompute a lot of features then\nyou're only doing a lookup and you'll likely have much less memory pressure but\nit is worth validating this before deploying your model.\n\n## 9: Monitor your model and features\n\nWhile this is the last item, it's an extremely important one. A general truth\nabout models is that if you're launching one it's going to be impactful to some\nprocess or customer experience (woo hoo!) but that means that people make\ntradeoffs to get things shipped and monitoring tends to be one of them.\n\nI've typically seen folks leave the monitoring of the model performance as some\nafterthought or follow up work to be completed later and usually it does and\nit's okay but it really should be top of mind. From a statistical standpoint\nthis is purely offensive as all sorts of chaotic things can go wrong\nwhen you go from some historical data to a live machine.\n\nIt could turn out that your data wasn't from a representative sample, your model\nwas trained on the wrong metric, you're adversely impacting business metrics\n(though this tends to be caught quickly), you have a bug in your code, or that\nyour model just doesn't work.\n\nYou can track most of that from monitoring, so don't omit it.\n\nMost importantly, every applied machine learning model that I've built in\nindustry has degraded (eventually). It's mostly because things change over time\nand that obviously makes sense. Without proper monitoring you will not be able\nto observe this phenomena so please don't forget this core component as it could\nbe very consequential to your business.\n\nIt's worth mentioning that model degradation not driven by engineering problems\nends up being a lot of statistical work to understand what is driving the\ndecay of models. Suffice it to say that it's a complex, high-dimensional\nproblem.\n\n\n# Some final thoughts\n\nReflecting on the list above, I can't help but call out that 9 of these 10 items\nare purely focused on the engineering around deploying a model and that the\nmonitoring is the **last** step.\n\n*As a brief aside, there is a significant amount of pre-work done here to build\nthese models during the model development lifecycle but I didn't discuss that\nhere as that's outside the scope of this blog post.*\n\nYou don't *actually* have to do anything on that list to get a model in production,\nI just recommend it. At an early stage of your service it may not even make sense\nto build a bullet-proof system but at a bigger scale these things actually do become\nincreasingly more important as preventative and defensive measures.\n\nLastly, I ranked these in order of importance and the most important ones are\nall *preventative change controls*, i.e., they can all detect breaks before you\ndeploy something to production (i.e. in unit tests). Defensive change controls\nare great too but one should remember that these will always come second place\nto preventative controls simply because you're catching a mistake after it's in\nproduction.\n\n\n*Have any feedback on this post? Let me know on the [twitter](https://twitter.com/franciscojarceo)!*\n"},"nextPost":null},"__N_SSG":true}